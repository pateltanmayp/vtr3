//////////////////////////////////////////////////////////////////////////////////////////////
/// \file LandmarkStateVar.hpp
///
/// \author Sean Anderson, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#include <vtr_vision/types.hpp>

namespace steam {
namespace se3 {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Constructor from a global 3D point
//////////////////////////////////////////////////////////////////////////////////////////////
LandmarkStateVar::LandmarkStateVar(const Eigen::Vector3d& v_0) : StateVar(3) {
  this->set(v_0);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Update the landmark state from the 3-dimensional perturbation
//////////////////////////////////////////////////////////////////////////////////////////////
bool LandmarkStateVar::update(const Eigen::VectorXd& perturbation) {

  if (perturbation.size() != this->getPerturbDim()) {
    throw std::runtime_error("During attempt to update a state variable, the provided "
                             "perturbation (VectorXd) was not the correct size.");
  }

  // todo: speed this up ? http://eigen.tuxfamily.org/dox/TopicWritingEfficientProductExpression.html
  this->value_.head<3>() += perturbation;
  this->refreshHomogeneousScaling();

  return true;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Clone method
//////////////////////////////////////////////////////////////////////////////////////////////
StateVarBase::Ptr LandmarkStateVar::clone() const {
  return LandmarkStateVar::Ptr(new LandmarkStateVar(*this));
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Set value -- mostly for landmark initialization
//////////////////////////////////////////////////////////////////////////////////////////////
void LandmarkStateVar::set(const Eigen::Vector3d& v) {

  this->value_.head<3>() = v;
  this->value_[3] = 1.0;
  this->refreshHomogeneousScaling();
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Refresh the homogeneous scaling
//////////////////////////////////////////////////////////////////////////////////////////////
void LandmarkStateVar::refreshHomogeneousScaling() {

  // Get length of xyz-portion of landmark
  const double invmag = 1.0/this->value_.head<3>().norm();

  // Update xyz-portion to be unit-length
  this->value_.head<3>() *= invmag;

  // Update scaling
  this->value_[3] *= invmag;
}

} // se3
} // steam
